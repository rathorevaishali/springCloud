import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Component;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.lang.reflect.Field;
import java.util.*;

@Aspect
@Component
public class PIIDataAccessAspect {

    private static final ObjectMapper objectMapper = new ObjectMapper();

    @Before("@annotation(PIIDataAccess) && args(responseEntity)")
    public void handlePIIDataAccess(ResponseEntity<?> responseEntity) throws IllegalAccessException {
        if (responseEntity == null || responseEntity.getBody() == null) {
            return; // No action needed for null or empty responses.
        }

        Object responseBody = responseEntity.getBody();
        Set<String> detectedPrivacyTags = new HashSet<>();

        // Detect privacy tags recursively
        detectPrivacyTags(responseBody, detectedPrivacyTags);

        if (!detectedPrivacyTags.isEmpty()) {
            logPrivacyTags(detectedPrivacyTags);
        }
    }

    private void detectPrivacyTags(Object obj, Set<String> detectedTags) throws IllegalAccessException {
        if (obj == null) {
            return;
        }

        if (obj instanceof Collection) {
            // Handle collections like Lists or Sets
            for (Object item : (Collection<?>) obj) {
                detectPrivacyTags(item, detectedTags);
            }
        } else if (obj instanceof Map) {
            // Handle maps (both keys and values)
            Map<?, ?> map = (Map<?, ?>) obj;
            for (Map.Entry<?, ?> entry : map.entrySet()) {
                detectPrivacyTags(entry.getKey(), detectedTags);
                detectPrivacyTags(entry.getValue(), detectedTags);
            }
        } else if (obj.getClass().isArray()) {
            // Handle arrays
            for (Object item : (Object[]) obj) {
                detectPrivacyTags(item, detectedTags);
            }
        } else if (isPrimitiveOrWrapper(obj.getClass())) {
            // Handle primitive types or wrappers
            String privacyTag = PrivacyTag.detectTag(obj.toString());
            if (privacyTag != null) {
                detectedTags.add(privacyTag);
            }
        } else {
            // Handle nested objects
            for (Field field : obj.getClass().getDeclaredFields()) {
                field.setAccessible(true);
                Object fieldValue = field.get(obj);

                if (fieldValue != null) {
                    detectPrivacyTags(fieldValue, detectedTags);
                }
            }
        }
    }

    private boolean isPrimitiveOrWrapper(Class<?> type) {
        return type.isPrimitive() || type.equals(String.class) || 
               Number.class.isAssignableFrom(type) || 
               Boolean.class.isAssignableFrom(type) ||
               Date.class.isAssignableFrom(type);
    }

    private void logPrivacyTags(Set<String> detectedTags) {
        // Log the detected privacy tags. Replace with your preferred logging mechanism.
        System.out.println("Detected Privacy Tags: " + detectedTags);
    }
}


public enum PrivacyTag {
    SENSITIVE_DEMOGRAPHIC_INFO,
    SENSITIVE_BACKGROUND_INFO,
    HEALTH_INFO,
    BIOMETRIC_INFO,
    FINANCIAL_ACCT_NO,
    CREDIT_DEBIT_CARD_NO,
    PARTIAL_CREDIT_DEBIT_CARD_NO,
    PERSONAL_FINANCIAL_INFO,
    SENSITIVE_PERSONAL_FINANCIAL_INFO;

    public static String detectTag(String value) {
        for (PrivacyTag tag : PrivacyTag.values()) {
            if (value.toUpperCase().contains(tag.name())) {
                return tag.name();
            }
        }
        return null;
    }
}
